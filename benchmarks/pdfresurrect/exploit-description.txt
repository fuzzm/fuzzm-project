Stack-based buffer overflow exploit found on https://www.exploit-db.com/exploits/47178

Reproduce exploit native:
- Compile the program (./configure + make)
- ./pdfresurrect malicious_document.pdf

Reproduce exploit wasm (does not result in a crash)
- run make clean if the native version was compiled previously
- make -f Makefile-wasm
- wasmtime --dir=. pdfresurrect.wasm ./malicious_document.pdf
(note, the --dir=. option is required to give the program the WASI capability for reading files in that dir).

// Description borrowed from exploit-db
In function pdf_load_xrefs at pdf.c file, it counts how many times the
strings '%%EOF' appear in the pdf file. Then for each xref the code
starts to rewind incrementing the pos_count variable until found a 'f'
character (the last character of the 'startxref' string). Then these
bytes between the 'f' and '%%EOF' will be read with the 'fread'
function and copied to a 256 char buffer. The 'pos_count' variable
tells 'freads' how many bytes has to copy. If malicious user crafted a
pdf file with more that 256 bytes between '%%EOF' and the immediately
previous 'f' then a buffer overflow will occur overwriting everything
after the 'buf' buffer.

The heap/stack cutoff value is 74288.
The overflowing buffer is located at 0x11f90 (73616).
The difference is 672 where 250 of the bytes is the buffer itself.
Hence there are 672-250 = 422 bytes of stack variables to overflow before reaching the heap

Expected stack trace from exploit (WASM):
Caused by:
    0: failed to invoke command default
    1: wasm trap: out of bounds memory access
       wasm backtrace:
         0: 0x25fc - <unknown>!pdf_load_xrefs
         1: 0x1035 - <unknown>!init_pdf
         2:  0x901 - <unknown>!main
         3: 0xbeac - <unknown>!__main_argc_argv
         4: 0xbf60 - <unknown>!__main_void
         5: 0xbaa1 - <unknown>!__original_main
         6:  0x3ce - <unknown>!_start

