#!TCLSH_PATH
#
# Usage:
#	blif2sim.tcl <blif_filename> <dir> [<sim_filename>]
#
# If cel_filename is not specified, then name will be the root name
# of the .blif file with the .sim extension.
#
# "dir" is the directory where .sim views of the standard cells are
# located.  If .sim views are not available but .mag files are, the
# .sim files will be generated automatically. 
#
#------------------------------------------------------------
# Written by Tim Edwards February 12, 2007
# MultiGiG, Inc.
#------------------------------------------------------------

set bliffile [lindex $argv 0]
set cellname [file rootname $bliffile]
if {"$cellname" == "$bliffile"} {
   set bliffile ${cellname}.blif
}

set prefix ""
if {$argc > 2} {
   if {[lindex $argv [expr {$argc - 2}]] == "-prefix"} {
      set prefix [lindex $argv [expr {$argc - 1}]]/
      incr argc -2
   }
}

if {$argc > 1} {
   set magdir [lindex $argv 1]
} else {
   set magdir /home/tim/projects/multigig/digital_flow/layout/digital2
}

if {$argc == 3} {
   set simfile [lindex $argv 2]
} else {
   set simfile ${cellname}.sim
}

set scriptdir [file dirname $argv0]

#-------------------------------------------------------------
# Open files for read and write

if [catch {open $bliffile r} fnet] {
   puts stderr "Error: can't open file $bliffile for reading!"
   exit 0
}

#----------------------------------------------------------------
# First, parse the contents of the .blif file and get a list
# of all macro names used.
#----------------------------------------------------------------

puts stdout "1st pass of blif file ${bliffile}. . ."
flush stdout

set macrolist {}
while {[gets $fnet line] >= 0} {
   if [regexp {^INSTANCE[ \t]+"([^"]+)"} $line lmatch macro] {
      lappend macrolist $macro
   }
}
set macrolist [lsort -unique $macrolist]
close $fnet

set needsims {}
foreach macro $macrolist {
   if {[glob -nocomplain ${magdir}/${macro}.sim] == {}} {
      lappend needsims ${macro}
   } elseif {[file size ${magdir}/${macro}.ext] == 0} {
      lappend needsims ${macro}
   }
}

if {$needsims != {}} {
   puts stdout "Generating .sim views. . ."
   flush stdout

   foreach macro $needsims {
      puts stdout "Generating ${macro}.sim"
      flush stdout
      catch {exec ${scriptdir}/makesim.sh ${magdir}/$macro}
   }
}

if [catch {open $simfile w} fsim] {
   puts stderr "Error: can't open file $simfile for writing!"
   exit 0
}

puts $fsim "| SIM file $simfile generated by blif2sim"

#----------------------------------------------------------------
# Procedure to dump the contents of a subcircuit .sim file to the
# top-level .sim file, replacing pin names with net names.
#----------------------------------------------------------------

proc dump_sim {fsim mode magdir prefix} {

   # Pick up variable definition from top-level
   upvar $mode mname

   # Make VDD, VSS, and GND show up as globals
   set mname(VDD)  VDD
   set mname(VDD!) VDD
   set mname(VSS)  VSS
   set mname(VSS!) VSS
   set mname(GND)  GND
   set mname(GND!) GND

   set fsub [open ${magdir}/${mode}.sim r]
   while {[gets $fsub line] >= 0} {
      set mtype [string index $line 0]

      # Parse .sim file lines.  Ignore lumped "R", which is not used by IRSIM.

      switch -exact $mtype {
	 n -
	 p { regexp {^[pn] ([^ ]+) ([^ ]+) ([^ ]+) (.*)} $line valid \
			gate drain source rest
	     puts -nonewline $fsim "$mtype "
	     if {[catch {puts -nonewline $fsim "${prefix}$mname(${gate}) "}]} {
		puts -nonewline $fsim "${prefix}${mode}$mname(count)/$gate "
	     }
	     if {[catch {puts -nonewline $fsim "${prefix}$mname(${drain}) "}]} {
		puts -nonewline $fsim "${prefix}${mode}$mname(count)/$drain "
	     }
	     if {[catch {puts -nonewline $fsim "${prefix}$mname(${source}) "}]} {
		puts -nonewline $fsim "${prefix}${mode}$mname(count)/$source "
	     }
	     puts $fsim $rest
	   }  
	 r { regexp {^r ([^ ]+) ([^ ]+) (.*)} $line valid r1 r2 rest
	     puts -nonewline $fsim "r "
	     if {[catch {puts -nonewline $fsim "${prefix}$mname(${r1}) "}]} {
		puts -nonewline $fsim "${prefix}${mode}$mname(count)/$r1 "
	     }
	     if {[catch {puts -nonewline $fsim "${prefix}$mname(${r2}) "}]} {
		puts -nonewline $fsim "${prefix}${mode}$mname(count)/$r2 "
	     }
	     puts $fsim $rest
	   }  
	 C { regexp {^C ([^ ]+) ([^ ]+) (.*)} $line valid top bottom rest
	     puts -nonewline $fsim "C "
	     if {[catch {puts -nonewline $fsim "${prefix}$mname(${top}) "}]} {
		puts -nonewline $fsim "${prefix}${mode}$mname(count)/$top "
	     }
	     if {[catch {puts -nonewline $fsim "${prefix}$mname(${bottom}) "}]} {
		puts -nonewline $fsim "${prefix}${mode}$mname(count)/$bottom "
	     }
	     puts $fsim $rest
	   }  
	 | { puts $fsim $line }
      }
   }
   close $fsub
}

#----------------------------------------------------------------
# Parse the contents of the .blif file again and dump each cell
# instance to the .sim file output.

puts stdout "2nd pass of blif file. . ."
flush stdout

set fnet [open $bliffile r]
set mode none
while {[gets $fnet line] >= 0} {
   if [regexp {^INSTANCE[ \t]+"([^"]+)"[ \t]*:[ \t]*"([^"]+)"} $line \
		lmatch macroname macrotype] {
      # New instance.  First dump the current instance to the sim file
      if {$mode != "pins" && $mode != "none"} { dump_sim $fsim $mode $magdir $prefix}

      # (There is now a valid mag/ext/sim file for TIELO and TIEHI)
      # if [string equal $macroname TIELO] {gets $fnet line; continue}
      # if [string equal $macroname TIEHI] {gets $fnet line; continue}
      set mode $macroname
      if {[catch {incr ${mode}(count)}]} {set ${mode}(count) 0}
   } elseif [regexp {^ENDMODEL} $line lmatch] {
      # Dump last "mode" output
      if {$mode != "pins"} { dump_sim $fsim $mode $magdir $prefix}
   } elseif [regexp {^INPUT} $line lmatch] {
      set mode "pins"
   } elseif [regexp {^OUTPUT} $line lmatch] {
      set mode "pins"
   } elseif [regexp {^MODEL[ \t]+"([^"]+)"} $line lmatch cellverify] {
      if {"$cellname" != "$cellverify"} {
	 puts -nonewline stderr "WARNING:  MODEL name ${cellverify} does not"
	 puts stderr " match filename ${cellname}!"
      }
   } elseif {"$mode" == "pins"} {
      if [regexp {"([^"]+)"[ \t]*:[ \t]*"([^"]+)"} $line lmatch pinname netname] {
	 # Don't do anything with these.
      }
   } else {
      # In the middle of parsing an instance;  mode = instance name (in lowercase).
      if [regexp {"([^"]+)"[ \t]*:[ \t]*"([^"]+)"} $line lmatch pinname netname] {
	 set ${mode}(${pinname}) $netname
      }
   }
}
# Dump the final instance to the sim file, if there was one.
if {$mode != "pins" && $mode != "none"} { dump_sim $fsim $mode $magdir $prefix}
close $fnet

puts stdout "Done!"
